package com.visma.kalmar.api.security;

import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;

import java.util.*;

/**
 * In our Internal environment we use AWS Cognito to mock Visma Connect's authentication and
 * authorization (OpenID and OAuth). AWS Cognito does not have the concept of Tenant ID.
 *
 * <p>We have an AWS API Gateway that acts as a proxy for AWS Cognito. This API Gateway appends to
 * the OAuth token, generated by AWS Cognito, the Tenant ID that the caller sends when asking for a
 * token.
 *
 * <p>This {@link JwtDecoder} takes the Tenant ID and can delegate the JWT decoding to a {@link
 * NimbusJwtDecoder}, which is what we use in Staging and Production environments too.
 */
public class MockJwtDecoder implements JwtDecoder {

    private static final String TENANT = "tenant";

    private final JwtDecoder jwtDecoder;

    public MockJwtDecoder(JwtDecoder jwtDecoder) {
        this.jwtDecoder = jwtDecoder;
    }

    @Override
    public Jwt decode(String token) throws JwtException {
        Optional<String> tenantIdOptional = getTenantIdOptional(token);
        final Jwt jwt;
        final Map<String, Object> claims;

        if (tenantIdOptional.isPresent()) {
            String tenantId = tenantIdOptional.get();
            jwt =
                    jwtDecoder.decode(
                            token.substring(0, token.length() - TENANT.length() - tenantId.length()));
            claims = new HashMap<>(jwt.getClaims());
            claims.put("tenant_id", tenantId);
        } else {
            jwt = jwtDecoder.decode(token);
            claims = new HashMap<>(jwt.getClaims());
        }

        return new Jwt(
                jwt.getTokenValue(),
                jwt.getIssuedAt(),
                jwt.getExpiresAt(),
                jwt.getHeaders(),
                Collections.unmodifiableMap(claims));
    }

    private Optional<String> getTenantIdOptional(String token) {
        if (token.contains(TENANT) && token.length() > TENANT.length() + 36) {
            final String tenantId = token.substring(token.length() - 36);
            try {
                UUID.fromString(tenantId);
                return Optional.of(tenantId);
            } catch (IllegalArgumentException e) {
                return Optional.empty();
            }
        }
        return Optional.empty();
    }
}
